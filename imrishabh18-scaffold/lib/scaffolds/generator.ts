// ===== Scaffold Generator =====
// Auto-generates scaffold template files from configuration

// Read command-line argument
const scaffoldType = process.argv[2] || "all"

// Scaffold type configurations
const SCAFFOLD_TYPES = {
  LrgLrg: {
    folder: "LrgLrg",
    configFile: "./LrgLrg/ScaffoldLrgLrgToGenerate",
    templateImport: "lib/scaffolds/LrgLrg/ScaffoldLrgLrgTemplate",
    componentName: "Scaffold_LrgLrg",
  },
  LrgMed: {
    folder: "LrgMed",
    configFile: "./LrgMed/ScaffoldLrgMedToGenerate",
    templateImport: "lib/scaffolds/LrgMed/ScaffoldLrgMedTemplate",
    componentName: "Scaffold_LrgMed",
  },
  // MedMed: {
  //   folder: "MedMed",
  //   configFile: "./MedMed/ScaffoldMedMedToGenerate",
  //   templateImport: "lib/scaffolds/MedMed/ScaffoldMedMedTemplate",
  //   componentName: "Scaffold_MedMed",
  // },
} as const

type ScaffoldTypeName = keyof typeof SCAFFOLD_TYPES

// Validate scaffold type argument
function validateScaffoldType(type: string): type is ScaffoldTypeName {
  return type in SCAFFOLD_TYPES
}

// Generate TSX content for a scaffold template
function generateScaffoldTSX(
  template: { fileName: string; size?: string; [key: string]: any },
  config: (typeof SCAFFOLD_TYPES)[ScaffoldTypeName],
): string {
  const { fileName, size, ...otherProps } = template

  // Build props for overrides
  const propsArray = Object.entries(otherProps)
    .filter(([key, value]) => value !== undefined && key !== "fileName")
    .map(([key, value]) => {
      if (typeof value === "string") {
        return `      ${key}="${value}"`
      }
      return `      ${key}={${JSON.stringify(value)}}`
    })

  const additionalProps =
    propsArray.length > 0 ? "\n" + propsArray.join("\n") : ""

  return `// Auto-generated by lib/scaffolds/generator.ts
// DO NOT EDIT THIS FILE MANUALLY

import ${config.componentName} from "${config.templateImport}";
import type { ReactNode } from "react";

export interface ${fileName}Props {
  children?: ReactNode;
  debug?: boolean;
  // Allow overriding any default props
  [key: string]: any;
}

export default function ${fileName}(props: ${fileName}Props = {}) {
  return (
    <${config.componentName}
      size="${size}"${additionalProps}
      {...props}
    />
  );
}
`
}

// Generate barrel file for a specific scaffold type
function generateScaffoldBarrel(
  templates: Array<{ fileName: string }>,
): string {
  const header = `// Auto-generated by lib/scaffolds/generator.ts
// DO NOT EDIT THIS FILE MANUALLY

`

  const exports = templates.map((template) => {
    return `export { default as ${template.fileName} } from "./generated/${template.fileName}"`
  })

  return header + exports.join("\n") + "\n"
}

// Validate no duplicate fileNames across all configs
function validateUniqueFileNames(allTemplates: Array<{ fileName: string }>) {
  const fileNames = allTemplates.map((t) => t.fileName)
  const duplicates = fileNames.filter(
    (name, index) => fileNames.indexOf(name) !== index,
  )
  if (duplicates.length > 0) {
    throw new Error(
      `Duplicate fileName(s) found: ${[...new Set(duplicates)].join(", ")}`,
    )
  }
}

// Ensure directory exists
async function ensureDirectory(dirPath: string) {
  try {
    await Bun.file(`${dirPath}/.keep`).exists()
  } catch {
    // Directory doesn't exist, create it
    await Bun.write(`${dirPath}/.keep`, "")
    await Bun.file(`${dirPath}/.keep`).unlink()
  }
}

// Ensure .gitignore exists in generated folder
async function ensureGitignore(outputDir: string) {
  const gitignorePath = `${outputDir}/.gitignore`
  const gitignoreContent = `# Ignore all generated scaffold files
*

# But keep this .gitignore file
#!.gitignore
`

  await Bun.write(gitignorePath, gitignoreContent)
}

// Clean old generated files from a directory
async function cleanGeneratedFiles(outputDir: string) {
  try {
    const existingFiles = await Array.fromAsync(
      new Bun.Glob("*.tsx").scan(outputDir),
    )
    for (const file of existingFiles) {
      const filePath = `${outputDir}/${file}`
      await Bun.file(filePath).unlink()
    }
    if (existingFiles.length > 0) {
      console.log(
        `  Cleaned ${existingFiles.length} old file(s) from ${outputDir}`,
      )
    }
  } catch (error) {
    // Directory might not exist yet or be empty, which is fine
  }
}

// Generate files for a specific scaffold type
async function generateScaffoldType(typeName: ScaffoldTypeName) {
  const config = SCAFFOLD_TYPES[typeName]
  console.log(`\nGenerating ${typeName} scaffolds...`)

  // Dynamic import of the config file
  const configModule = await import(config.configFile)
  const configArray = configModule[`Scaffold${typeName}ToGenerate`]

  if (!Array.isArray(configArray) || configArray.length === 0) {
    console.log(`  No templates found in ${config.configFile}`)
    return []
  }

  const outputDir = `./lib/scaffolds/${config.folder}/generated`

  // Ensure directory exists
  await ensureDirectory(outputDir)

  // Ensure .gitignore exists
  await ensureGitignore(outputDir)

  // Clean old files
  await cleanGeneratedFiles(outputDir)

  // Generate files
  const templates: Array<{ fileName: string; folder: string }> = []
  for (const template of configArray) {
    const content = generateScaffoldTSX(template, config)
    const filePath = `${outputDir}/${template.fileName}.tsx`

    await Bun.write(filePath, content)
    console.log(`  Generated: ${filePath}`)
    templates.push({ fileName: template.fileName, folder: config.folder })
  }

  // Generate barrel file for this scaffold type
  const barrelContent = generateScaffoldBarrel(templates)
  const barrelPath = `./lib/scaffolds/${config.folder}/scaffolds-${config.folder}.ts`
  await Bun.write(barrelPath, barrelContent)
  console.log(`  Generated barrel: ${barrelPath}`)

  return templates
}

// Main generator function
async function generateFiles() {
  console.log("Scaffold Generator")
  console.log("==================\n")

  // Determine which types to generate
  let typesToGenerate: ScaffoldTypeName[]

  if (scaffoldType === "all") {
    typesToGenerate = Object.keys(SCAFFOLD_TYPES) as ScaffoldTypeName[]
    console.log("Generating all scaffold types...")
  } else if (validateScaffoldType(scaffoldType)) {
    typesToGenerate = [scaffoldType]
    console.log(`Generating ${scaffoldType} scaffolds only...`)
  } else {
    console.error(`Error: Invalid scaffold type "${scaffoldType}"`)
    console.error(`Valid types: ${Object.keys(SCAFFOLD_TYPES).join(", ")}, all`)
    process.exit(1)
  }

  // Generate each type
  const allTemplates: Array<{ fileName: string; folder: string }> = []
  for (const type of typesToGenerate) {
    const templates = await generateScaffoldType(type)
    allTemplates.push(...templates)
  }

  // Validate no duplicates
  validateUniqueFileNames(allTemplates)

  console.log(
    `\nâœ“ Successfully generated ${allTemplates.length} scaffold file(s) + ${typesToGenerate.length} barrel file(s)`,
  )
}

// Run the generator
generateFiles().catch((error) => {
  console.error("Error generating scaffolds:", error)
  process.exit(1)
})
