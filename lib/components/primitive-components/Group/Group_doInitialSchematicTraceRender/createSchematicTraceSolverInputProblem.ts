import type { SourceNet } from "circuit-json"
import { Group } from "../Group"
import {
  type InputChip,
  type InputPin,
  type InputProblem,
} from "@tscircuit/schematic-trace-solver"
import type { AxisDirection } from "./getSide"

export type SolverInputContext = {
  inputProblem: InputProblem
  pinIdToSchematicPortId: Map<string, string>
  pairKeyToSourceTraceId: Map<string, string>
  /**
   * Subcircuit connectivity map key to source_net
   * e.g.
   * Map(
   *   "unnamedsubcircuit52_connectivity_net2": {
   *     type: "source_net",
   *     source_net_id: "source_net_2",
   *     name: "V3_3",
   *     member_source_group_ids: [],
   *     subcircuit_id: "subcircuit_source_group_1",
   *     subcircuit_connectivity_map_key: "unnamedsubcircuit52_connectivity_net2",
   *   }, ...
   * )
   */
  sckToSourceNet: Map<string, SourceNet>

  /**
   * Subcircuit connectivity key to user net id
   * e.g.
   * Map(
   *   "unnamedsubcircuit52_connectivity_net2": "V3_3",
   *   "unnamedsubcircuit52_connectivity_net3": "GND",
   *   ...
   * )
   */
  sckToUserNetId: Map<string, string>

  /**
   * User net id to subcircuit connectivity key
   * e.g.
   * Map(
   *   "V3_3": "unnamedsubcircuit52_connectivity_net2",
   *   "GND": "unnamedsubcircuit52_connectivity_net3",
   *   ...
   * )
   */
  userNetIdToSck: Map<string, string>

  allSourceAndSchematicPortIdsInScope: Set<string>
  schPortIdToSourcePortId: Map<string, string>
  displayLabelTraces: any[]

  allScks: Set<string>
}

export function createSchematicTraceSolverInputProblem(
  group: Group<any>,
): SolverInputContext {
  const { db } = group.root!

  const sckToSourceNet = new Map<string, any>()
  const sckToUserNetId = new Map<string, string>()
  const allScks = new Set<string>()

  // Traces excluded from routing (only need labels)
  const traces = group.selectAll("trace")
  const displayLabelTraces = traces.filter(
    (t: any) => t._parsedProps?.schDisplayLabel,
  )

  // Gather all schematic components in scope (this group and child groups)
  const childGroups = group.selectAll("group") as Group<any>[]
  const allSchematicGroupIds = [
    group.schematic_group_id,
    ...childGroups.map((a) => a.schematic_group_id),
  ]

  const schematicComponents = db.schematic_component
    .list()
    .filter((a) => allSchematicGroupIds.includes(a.schematic_group_id!))

  // Build chips and pinId maps
  const chips: InputChip[] = []
  const pinIdToSchematicPortId = new Map<string, string>()
  const schematicPortIdToPinId = new Map<string, string>()

  for (const schematicComponent of schematicComponents) {
    const chipId = schematicComponent.schematic_component_id
    const pins: InputPin[] = []

    const sourceComponent = db.source_component.getWhere({
      source_component_id: schematicComponent.source_component_id,
    })

    const schematicPorts = db.schematic_port.list({
      schematic_component_id: schematicComponent.schematic_component_id,
    })

    for (const schematicPort of schematicPorts) {
      const pinId = `${sourceComponent?.name ?? schematicComponent.schematic_component_id}.${schematicPort.pin_number}`
      pinIdToSchematicPortId.set(pinId, schematicPort.schematic_port_id)
      schematicPortIdToPinId.set(schematicPort.schematic_port_id, pinId)
    }

    for (const schematicPort of schematicPorts) {
      const pinId = schematicPortIdToPinId.get(schematicPort.schematic_port_id)!
      pins.push({
        pinId,
        x: schematicPort.center.x,
        y: schematicPort.center.y,
      })
    }

    chips.push({
      chipId,
      center: schematicComponent.center,
      width: schematicComponent.size.width,
      height: schematicComponent.size.height,
      pins,
    })
  }

  // Maps for ports within this scope
  const allSourceAndSchematicPortIdsInScope = new Set<string>()
  const schPortIdToSourcePortId = new Map<string, string>()
  const sourcePortIdToSchPortId = new Map<string, string>()
  const userNetIdToSck = new Map<string, string>()
  for (const sc of schematicComponents) {
    const ports = db.schematic_port.list({
      schematic_component_id: sc.schematic_component_id,
    })
    for (const sp of ports) {
      allSourceAndSchematicPortIdsInScope.add(sp.schematic_port_id)
      if (sp.source_port_id) {
        schPortIdToSourcePortId.set(sp.schematic_port_id, sp.source_port_id)
        sourcePortIdToSchPortId.set(sp.source_port_id, sp.schematic_port_id)
      }
    }
  }

  // Determine allowed subcircuits (this group and its child groups)
  const allowedSubcircuitIds = new Set<string>()
  if (group.subcircuit_id) allowedSubcircuitIds.add(group.subcircuit_id)
  for (const cg of childGroups) {
    if (cg.subcircuit_id) allowedSubcircuitIds.add(cg.subcircuit_id)
  }

  // Find all traces that are either in this subcircuit or connected to ports
  // within this subcircuit. This is necessary for traces that cross subcircuit
  // boundaries.
  const tracesInScope = db.source_trace.list().filter((st) => {
    if (st.subcircuit_id === group.subcircuit_id) return true
    for (const source_port_id of st.connected_source_port_ids) {
      if (sourcePortIdToSchPortId.has(source_port_id)) return true
    }
    return false
  })

  const externalNetIds = tracesInScope.flatMap(
    (st) => st.connected_source_net_ids,
  )

  for (const netId of externalNetIds) {
    const net = db.source_net.get(netId)
    if (net?.subcircuit_id) {
      allowedSubcircuitIds.add(net.subcircuit_id)
    }
  }

  // Direct connections derived from explicit source_traces
  const directConnections: Array<{ pinIds: [string, string]; netId?: string }> =
    []
  const pairKeyToSourceTraceId = new Map<string, string>()
  for (const st of db.source_trace.list()) {
    if (st.subcircuit_id && !allowedSubcircuitIds.has(st.subcircuit_id)) {
      continue
    }
    const connected = (st.connected_source_port_ids ?? [])
      .map((srcId: string) => sourcePortIdToSchPortId.get(srcId))
      .filter(
        (sourcePortId): sourcePortId is string =>
          Boolean(sourcePortId) &&
          allSourceAndSchematicPortIdsInScope.has(sourcePortId!),
      )

    if (connected.length >= 2) {
      const [a, b] = connected.slice(0, 2)
      const pairKey = [a, b].sort().join("::")
      if (!pairKeyToSourceTraceId.has(pairKey)) {
        pairKeyToSourceTraceId.set(pairKey, st.source_trace_id)
        const userNetId = st.display_name ?? st.source_trace_id
        if (st.subcircuit_connectivity_map_key) {
          allScks.add(st.subcircuit_connectivity_map_key)
          userNetIdToSck.set(userNetId, st.subcircuit_connectivity_map_key)
          sckToUserNetId.set(st.subcircuit_connectivity_map_key, userNetId)
        }
        directConnections.push({
          pinIds: [a, b].map((id) => schematicPortIdToPinId.get(id)!) as [
            string,
            string,
          ],
          netId: userNetId,
        })
      }
    }
  }

  // Net connections derived from named nets (source_net) in-scope
  const netConnections: Array<{
    netId: string
    pinIds: string[]
    netLabelWidth?: number
  }> = []
  for (const net of db.source_net
    .list()
    .filter(
      (n) => !n.subcircuit_id || allowedSubcircuitIds.has(n.subcircuit_id!),
    )) {
    if (net.subcircuit_connectivity_map_key) {
      allScks.add(net.subcircuit_connectivity_map_key)
      sckToSourceNet.set(net.subcircuit_connectivity_map_key, net)
    }
  }

  /**
   * Subcircuit connectivity map key to schematic port ids
   */
  const sckToPinIds = new Map<string, string[]>()
  for (const [schId, srcPortId] of schPortIdToSourcePortId) {
    const sp = db.source_port.get(srcPortId)
    if (!sp?.subcircuit_connectivity_map_key) continue
    const sck = sp.subcircuit_connectivity_map_key
    allScks.add(sck)
    if (!sckToPinIds.has(sck)) sckToPinIds.set(sck, [])
    sckToPinIds.get(sck)!.push(schId)
  }

  for (const [subcircuitConnectivityKey, schematicPortIds] of sckToPinIds) {
    const sourceNet = sckToSourceNet.get(subcircuitConnectivityKey)
    if (sourceNet && schematicPortIds.length >= 2) {
      const userNetId = String(
        sourceNet.name || sourceNet.source_net_id || subcircuitConnectivityKey,
      )
      userNetIdToSck.set(userNetId, subcircuitConnectivityKey)
      sckToUserNetId.set(subcircuitConnectivityKey, userNetId)

      // Estimate net label width using same heuristic as computeSchematicNetLabelCenter
      // Default font_size is 0.18 and charWidth = 0.1 * (font_size / 0.18)
      const fontSize = 0.18
      const charWidth = 0.1 * (fontSize / 0.18)
      const netLabelWidth = Number(
        (String(userNetId).length * charWidth).toFixed(2),
      )

      netConnections.push({
        netId: userNetId,
        pinIds: schematicPortIds.map(
          (portId) => schematicPortIdToPinId.get(portId)!,
        ),
        netLabelWidth,
      })
    }
  }

  // Available net label orientations from source_net naming conventions
  const availableNetLabelOrientations: Record<string, AxisDirection[]> =
    (() => {
      const netToAllowedOrientations: Record<string, AxisDirection[]> = {}
      const presentNetIds = new Set(netConnections.map((nc) => nc.netId))
      for (const net of db.source_net
        .list()
        .filter(
          (n) => !n.subcircuit_id || allowedSubcircuitIds.has(n.subcircuit_id),
        )) {
        if (!net.name) continue
        if (!presentNetIds.has(net.name)) continue
        if (net.is_ground || net.name.toLowerCase().startsWith("gnd")) {
          netToAllowedOrientations[net.name] = ["y-"]
        } else if (net.is_power || net.name.toLowerCase().startsWith("v")) {
          netToAllowedOrientations[net.name] = ["y+"]
        } else {
          netToAllowedOrientations[net.name] = ["x-", "x+"]
        }
      }
      return netToAllowedOrientations
    })()

  const inputProblem: InputProblem = {
    chips,
    directConnections,
    netConnections,
    availableNetLabelOrientations,
    maxMspPairDistance: group._parsedProps.schMaxTraceDistance ?? 2.4,
  }

  return {
    inputProblem,
    pinIdToSchematicPortId,
    pairKeyToSourceTraceId,
    sckToSourceNet,
    sckToUserNetId,
    userNetIdToSck,
    allSourceAndSchematicPortIdsInScope,
    schPortIdToSourcePortId,
    displayLabelTraces,
    allScks,
  }
}
